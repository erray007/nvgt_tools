const double pi = 3.1415926535897932384626433832795;

// helper: clamp a value to a minimum and maximum
double clamp(double value, double min, double max){
value=value<min? min:value;
value=value>max? max:value;
return value;
}

string pack_audio(float[] data) {
    datastream ds;
    ds.binary = true;
    for (uint i = 0; i < data.length(); i++) {
        ds.write_float(data[i]);
    }
    return ds.str();
}

float[]@ unpack_audio(string data) {
    datastream ds;
    ds.binary = true;
    float[] result; // Changed from 'float result;' to 'float[] result;'
    while (ds.good) {
        result.insert_last(ds.read_float());
    }
    return @result;
}

float[]@ sinewave(uint freq, double dur, double amp = 1.0, uint sr = 44100) {
    uint num_samples = (dur / 1000) * sr;
    float[] samples;
    samples.resize(num_samples);
    double phi = 0.0; // phase accumulator
    const double delta = 2 * pi * freq / sr; // phase increment per sample
    uint t;
    for (t = 0; t < num_samples; t++) {
        samples[t] = amp * sin(phi);
        phi += delta;
    }
    return @samples;
}

void pad_shortest(float[]@ first, float[]@ second) {
    if (first.length() > second.length()) {
        while (second.length() != first.length()) second.insert_last(0.0);
    } else {
        while (first.length() != second.length()) first.insert_last(0.0);
    }
}

float[]@ ringmod(float[]@ modulator, float[]@ carrier) {
    pad_shortest(carrier, modulator);

    float[] result;
    result.resize(carrier.length()); // Added this line to properly initialize 'result' array
    for (uint i = 0; i < carrier.length(); i++) {
        result[i] = carrier[i] * modulator[i];
    }
    return @result;
}

sound@ push_audio(float[]@ data, uint sr = 44100, uint channels = 1, bool stream_end=false) {
    const string bytes = pack_audio(data); // Changed from 'unpack_audio(data)' to 'pack_audio(data)'
    sound s;
    s.load("");
    s.push_memory(bytes, stream_end, sr, channels);
    return @s; 
}

sound@ push_audio(const string&in bytes, uint sr = 44100, uint channels = 1, bool stream_end=false) {
    sound s;
    s.load("");
    s.push_memory(bytes, stream_end, sr, channels);
    return @s; 
}

bool push_audio(sound@ s, float[]@ data, uint sr = 44100, uint channels = 1, bool stream_end=false) {
    const string bytes = pack_audio(data); // Changed from 'unpack_audio(data)' to 'pack_audio(data)'
    if (!s.active) s.load("");
    return s.push_memory(bytes, stream_end, sr, channels);
}

bool push_audio(sound@ s, const string&in bytes, uint sr = 44100, uint channels = 1, bool stream_end=false) {
    if (!s.active) s.load("");
    return s.push_memory(bytes, stream_end, sr, channels);
}

float[]@ silence(float dur, uint sr=44100){
    uint num_samples=(dur/1000)*sr;
    float[] result;
    result.resize(num_samples);
    return @result;
}

float[]@ white_noise(float dur, float amp=1.0, float density=1.0, uint sr=44100, uint channels=1){
    density=float(clamp(density,0.0,1.0));
    density/=2;
    density*=100;
    uint num_samples=(dur/1000)*sr*channels;
    float[] result;
    result.reserve(num_samples);
    for(uint i=0; i<num_samples; i++){
        result.insert_last(random_bool(density)? amp: -amp);
    }
    return @result;
}

float[]@ saw_wave(uint freq, double dur, double amp = 1.0, uint sr = 44100) {
    uint num_samples = (dur / 1000) * sr;
    float[] samples;
    samples.resize(num_samples);
    double period = sr / double(freq);
    for (uint t = 0; t < num_samples; t++) {
        samples[t] = amp * (2.0 * ((t % uint(period)) / period) - 1.0);
    }
    return @samples;
}

float[]@ amplitude(float[]@ data, float amp){
    float[] result;
    result.reserve(data.length());
    for(uint i=0; i<data.length(); i++){
        result.insert_last(data[i]*amp);
    }
    return @result;
}

float[]@ flip_polarity(float[]@ data){
    return amplitude(data, -1.0);
}

float[]@ dc_offset(float value, float dur, uint sr=44100){
    uint num_samples=(dur/1000)*sr;
    float[] result;
    result.reserve(num_samples);
    for(uint i=0; i<num_samples; i++){
        result.insert_last(value);
    }
    return @result;
}

float[]@ pulse_wave(uint freq, float dur, float pulse_width=0.5, float amp=1.0, uint sr=44100) {
    uint num_samples = uint((dur / 1000.0) * sr);
    float[] samples(num_samples);
    uint period = uint(sr / freq);
    uint high_time = uint(period * pulse_width);

    for (uint t = 0; t < num_samples; t++) {
        if ((t % period) < high_time) {
            samples[t] = amp;
        } else {
            samples[t] = -amp;
        }
    }

    return @samples;
}

float[]@ triangle_wave(uint freq, float dur, float amp=1.0, uint sr=44100) {
    uint num_samples = uint((dur / 1000.0) * sr);
    float[] samples(num_samples);
    float period = sr / float(freq);
    float half_period = period / 2;

    for (uint t = 0; t < num_samples; t++) {
        float pos_in_period = float(t % uint(period));
        if (pos_in_period < half_period) {
            samples[t] = 2.0 * amp * (pos_in_period / half_period) - amp;
        } else {
            samples[t] = 2.0 * amp * (1.0 - (pos_in_period - half_period) / half_period) - amp;
        }
    }

    return @samples;
}

float apply_curve(float value, float curve) {
    if (curve == 1.0) return value; // Linear
    return pow(value, 1/curve);
}

float[]@ adsr_envelope(float[]@ data, float attack=0.0, float decay=0.0, float sustain=1.0, float release=0.0, float curve=2.0, uint sr=44100) {
    uint total_samples = data.length();
    uint attack_samples = uint((attack / 1000.0) * sr);
    uint decay_samples = uint((decay / 1000.0) * sr);
    uint release_samples = uint((release / 1000.0) * sr);
    uint sustain_samples = total_samples - (attack_samples + decay_samples + release_samples);

    float[] envelope(total_samples);
    uint t;

    // Attack phase
    for (t = 0; t < attack_samples; t++) {
        envelope[t] = apply_curve(t / float(attack_samples), curve);
    }

    // Decay phase
    for (uint i = 0; i < decay_samples; i++, t++) {
        envelope[t] = 1.0 - apply_curve((1.0 - sustain) * (i / float(decay_samples)), curve);
    }

    // Sustain phase
    for (uint i = 0; i < sustain_samples; i++, t++) {
        envelope[t] = sustain;
    }

    // Release phase
    for (uint i = 0; i < release_samples; i++, t++) {
        envelope[t] = sustain * apply_curve(1.0 - (i / float(release_samples)), curve);
    }

    // Apply the envelope to the data
    float[] result(total_samples);
    for (t = 0; t < total_samples; t++) {
        result[t] = data[t] * envelope[t];
    }

    return @result;
}

float[]@ downsample(float[]@ data, uint factor){
    if(factor==1)return data;
    float[] result;
    result.reserve(data.length());
    for(uint i=0; i<data.length(); i++){
        result.insert_last(i%factor==0?data[i]:0.0);
    }
    return @result;
}